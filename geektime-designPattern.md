# 设计模式

## 07 理论四：哪些代码看似是面向对象的，实际是面向过程的

### 1. 滥用 getter、setter 方法

在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。

### 2.Constants 类、Utils 类的设计问题

对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。

### 3. 基于贫血模型的开发模式

关于这一部分，我们只讲了为什么这种开发模式是彻彻底底的面向过程编程风格的。这是因为数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的。今天，你只需要掌握这一点就可以了。为什么这种开发模式如此流行？如何规避面向过程编程的弊端？有没有更好的可替代的开发模式？相关的更多问题，我们在面向对象实战篇中会一一讲解。

## 08 理论五：接口和抽象类比较

抽象类特性：

- 抽象类不允许被实例化，只能被继承
- 抽象类可以包含属性和方法
- 子类继承抽象类，必须实现抽象类中的所有抽象方法

接口特性：

- 接口不能包含属性
- 接口只能声明方法，不能包含代码实现
- 类实现接口的时候，必须实现接口中声明的方法

从设计角度的比较：

- 抽象类：一中特殊的类，和实现类是 is-a 关系
- 接口：形象的说法是协议，表示具有某些功能，是一中 has-a 关系

使用场景：

- 表示 is-a 关系，为了实现代码复用，使用抽象类
- 表示 has-a 关系，为了解决抽象而非代码复用，使用接口

## 09 为什么基于接口而非实现编程

接口的定义只表明做什么，而不是怎么做

基于接口而非实现编程原则：

- 行数的命名不应该暴露任何实现细节
- 封装具体的实现细节
- 为实现类定义抽象的接口